<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>创建一个传感器 - 交通仿真器文档</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u521b\u5efa\u4e00\u4e2a\u4f20\u611f\u5668";
        var mkdocs_page_input_path = "tuto_D_create_sensor.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 交通仿真器文档
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">主页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">入门</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../start_introduction/">介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../start_quickstart/">快速启动包安装</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_first_steps/">第一步</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">构建 Carla</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../build_carla/">构建 Carla</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_linux/">Linux 构建</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_windows/">Windows 构建</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_update/">更新 Carla</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_system/">构建系统</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_docker/">Docker 中的 Carla</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_faq/">常问的问题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">下一步</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_content_authoring_maps/">内容创作 - 地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_content_authoring_vehicles/">内容创作 - 车辆</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Carla 主题</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../foundations/">基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../core_concepts/">核心概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../core_world/">世界和客户端</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../core_actors/">参与者和蓝图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ts_traffic_simulation_overview/">交通</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../core_map/">地图和导航 </a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../core_sensors/">传感器和数据</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../development_tutorials/">开发</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../custom_assets_tutorials/">自定义资产</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">高级概念</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_recorder/">记录器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_rendering_options/">渲染选项</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_synchrony_timestep/">同步和时间步长</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_benchmarking/">基准性能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_agents/">Carla 智能体</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">交通仿真</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_traffic_manager/">交通管理器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_sumo/">SUMO 联合仿真</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_scenic/">Scenic</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">资源</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../python_api/">Python API 参考</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_cpp/">C++ 参考</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bp_library/">蓝图库</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../catalogue/">Carla 目录</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_recorder_binary_file_format/">记录器二进制文件格式</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_sensors/">传感器参考</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/">教程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ext_docs/">扩展文档</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">插件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../plugins_carlaviz/">carlaviz — web 可视化器</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">ROS 桥接器</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ros_documentation/">ROS 桥文档</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">自定义地图</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_map_overview/">Carla 中自定义地图的概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_generate_map/">在 RoadRunner 中创建地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_add_map_package/">在 Carla 包导入地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_add_map_source/">在 Carla 源构建中导入地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_add_map_alternative/">导入地图的替代方法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_manual_map_package/">手动准备地图包</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_layers/">自定义地图：分层地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_add_tl/">自定义地图：红绿灯和标志</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_road_painter/">自定义地图：道路画家</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_buildings/">自定义地图：程序建筑</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_custom_weather_landscape/">自定义地图：天气和景观</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_M_generate_pedestrian_navigation/">生成行人导航</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">大型地图</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../large_map_overview/">大型地图概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../large_map_roadrunner/">在RoadRunner中创建大地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../large_map_import/">导入/打包大地图</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">教程（通用）</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_add_friction_triggers/">添加摩擦触发器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_control_vehicle_physics/">控制车辆物理模型</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_control_walker_skeletons/">控制行人骨骼</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_openstreetmap/">使用 OpenStreetMap 生成地图</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_retrieve_data/">检索仿真数据</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build_docker_unreal/">在 Docker 中构建虚幻引擎和 Carla</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">教程（资产）</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_A_add_vehicle/">添加新车辆</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_A_add_props/">添加新道具</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_A_create_standalone/">创建独立包</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_A_material_customization/">材质定制</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">教程（开发人员）</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_D_contribute_assets/">如何升级内容</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">创建一个传感器</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">先决条件</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">介绍</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">创建新传感器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-">1- 创建新传感器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-">2- 传感器数据串行器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-">3- 传感器数据对象</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-">4- 注册您的传感器</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5-">5- 使用示例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">附录</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_6">重用缓冲区</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">异步发送数据</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">客户端传感器</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_D_create_semantic_tags/">创建语义标签</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_D_customize_vehicle_suspension/">自定义车辆悬架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_D_generate_colliders/">生成详细碰撞</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_D_make_release/">发布版本</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Carla 生态系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ecosys_ansys/">Ansys 实时雷达模型</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_rllib_integration/">RLlib 集成</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_carsim_integration/">CarSim 集成</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_chrono/">Chrono 集成</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_opendrive/">OpenDRIVE 独立模式</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_ptv/">PTV-Vissim 联合仿真</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../adv_rss/">责任敏感安全</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="https://carla.readthedocs.io/projects/ros-bridge/en/latest/">机器人操作系统</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tuto_G_G29_windows/">罗技 G29 方向盘</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">贡献</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../cont_contribution_guidelines/">贡献指南</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cont_code_of_conduct/">行为准则</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cont_coding_standard/">编码标准</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cont_doc_standard/">文档标准</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">交通仿真器文档</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">教程（开发人员）</li>
      <li class="breadcrumb-item active">创建一个传感器</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">如何添加新传感器</h1>
<p>本教程介绍了向 Carla 添加新传感器的基础知识。它提供了在虚幻引擎 4 中实现传感器并通过 Carla 的 Python API 公开其数据的必要步骤。我们将通过创建新传感器作为示例来遵循所有步骤。</p>
<ul>
<li><a href="#prerequisites"><strong>先决条件</strong></a>  </li>
<li><a href="#introduction"><strong>介绍</strong></a>  </li>
<li><a href="#creating-a-new-sensor"><strong>创建新传感器</strong></a>  <ul>
<li><a href="#1-sensor-actor">1- 传感器参与者</a>  </li>
<li><a href="#2-sensor-data-serializer">2- 传感器数据串行器</a>  </li>
<li><a href="#3-sensor-data-object">3- 传感器数据对象</a>  </li>
<li><a href="#4-register-your-sensor">4- 注册您的传感器</a>  </li>
<li><a href="#5-usage-example">5- 使用示例</a>  </li>
</ul>
</li>
<li><a href="#appendix"><strong>附录</strong></a>  <ul>
<li><a href="#reusing-buffers">重用缓冲区</a>  </li>
<li><a href="#sending-data-asynchronously">异步发送数据</a>  </li>
<li><a href="#client-side-sensors">客户端传感器</a>  </li>
</ul>
</li>
</ul>
<hr />
<h2 id="_2">先决条件</h2>
<p>为了实现新的传感器，您需要编译 Carla 源代码，有关如何实现此目的的详细说明，请参阅 <a href="../build_linux/">从源代码构建</a> 。</p>
<p>本教程还假设读者精通 C++ 编程。</p>
<hr />
<h2 id="_3">介绍</h2>
<p>Carla 中的传感器是一种特殊类型的参与者，可以产生数据流。有些传感器每次更新时都会连续产生数据，而另一些传感器仅在某些事件发生后才产生数据。例如，相机在每次更新时都会生成图像，但碰撞传感器仅在发生碰撞时才会触发。</p>
<p>尽管大多数传感器在服务器端（虚幻引擎 4）中计算测量结果，但值得注意的是，某些传感器仅在客户端中运行。此类传感器的一个例子是 LaneInvasion，每次越过车道标记时它都会发出通知。有关更多详细信息，请参阅 <a href="#appendix-client-side-sensors">附录：客户端传感器</a> 。</p>
<p>在本教程中，我们将重点关注服务器端传感器。</p>
<p>为了让虚幻引擎 4 内运行的传感器将数据一路发送到 Python 客户端，我们需要覆盖整个通信管道。</p>
<p><img alt="Communication pipeline" src="../img/pipeline.png" /></p>
<p>因此，我们需要以下类来涵盖管道的不同步骤</p>
<ul>
<li>
<p><strong>传感器参与者</strong><br>
    负责测量和/或模拟数据的参与者。使用虚幻引擎 4框架在 Carla 插件中运行。用户可以作为传感器参与者访问。</p>
</li>
<li>
<p><strong>串行器</strong><br>
    对象包含用于序列化和反序列化传感器生成的数据的方法。在 LibCarla 中运行，包括服务器和客户端。</p>
</li>
<li>
<p><strong>传感器数据</strong><br>
    表示传感器生成的数据的对象。这是将在 C++ 和 Python API 中传递给最终用户的对象。</p>
</li>
</ul>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>为了确保最佳性能，传感器使用基于模板元编程的“编译时插件系统”进行注册和调度。最有可能的是，在所有部分都存在之前，代码不会编译。</p>
</div>
<hr />
<h2 id="_4">创建新传感器</h2>
<p><a href="https://gist.github.com/nsubiron/011fd1b9767cd441b1d8467dc11e00f9"><strong>完整源代码在这里。</strong></a></p>
<p>我们将创建一个传感器来检测车辆周围的其他参与者。为此，我们将创建一个触发盒来检测其中的物体，并且每次车辆进入触发盒时我们都会向客户端报告状态。我们称之为 <em>安全距离传感器</em> 。</p>
<p><img alt="Trigger box" src="../img/safe_distance_sensor.jpg" /></p>
<p><em>为了简单起见，我们不会考虑所有的边缘情况，也不会以最有效的方式实现。这只是一个说明性示例。</em></p>
<h3 id="1-">1- 创建新传感器</h3>
<p>这是我们要创建的最复杂的类。这里我们在虚幻引擎框架内运行，虚幻引擎 4 API 的知识将非常有帮助，但不是必不可少的，我们假设读者以前从未使用过虚幻引擎 4。</p>
<p>在 <code>UE4</code> 内部，我们有一个与客户端类似的层次结构，<code>ASensor</code> 派生自<code>AActor</code>，而 <code>Actor</code> 大致是可以放入世界中的任何对象。<code>AActor</code>有一个名为的虚拟函数<code>Tick</code>，我们可以使用它在每次模拟器更新时更新我们的传感器。在更高的层次结构中 <code>UObject</code>，我们有大多数虚幻引擎 4 类的基类。重要的是要知道派生的对象<code>UObject</code>是通过指针进行处理的，并且当它们不再被引用时会被垃圾收集。指向 <code>UObjects</code> 的类成员需要用宏<code>UPROPERTY</code>进行标记，否则它们将被垃圾收集。</p>
<p>开始吧。</p>
<p>该类必须位于 Carla 插件内，我们将为新的 C++ 类创建两个文件</p>
<ul>
<li><code>Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Sensor/SafeDistanceSensor.h</code></li>
<li><code>Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Sensor/SafeDistanceSensor.cpp</code></li>
</ul>
<p>最起码，传感器需要继承<code>ASensor</code>，并提供静态方法<code>GetSensorDefinition</code>；但我们还将重写<code>Set</code>、 <code>SetOwner</code>、 和<code>Tick</code>方法。该传感器还需要一个触发盒来检测我们周围的其他参与者。有了这个和一些必需的虚幻引擎4 样板代码，头文件看起来像</p>
<pre><code class="language-cpp">#pragma once

#include &quot;Carla/Sensor/Sensor.h&quot;

#include &quot;Carla/Actor/ActorDefinition.h&quot;
#include &quot;Carla/Actor/ActorDescription.h&quot;

#include &quot;Components/BoxComponent.h&quot;

#include &quot;SafeDistanceSensor.generated.h&quot;

UCLASS()
class CARLA_API ASafeDistanceSensor : public ASensor
{
  GENERATED_BODY()

public:

  ASafeDistanceSensor(const FObjectInitializer &amp;ObjectInitializer);

  static FActorDefinition GetSensorDefinition();

  void Set(const FActorDescription &amp;ActorDescription) override;

  void SetOwner(AActor *Owner) override;

  void Tick(float DeltaSeconds) override;

private:

  UPROPERTY()
  UBoxComponent *Box = nullptr;
};
</code></pre>
<p>在 cpp 文件中，首先我们需要一些包含</p>
<pre><code class="language-cpp">#include &quot;Carla.h&quot;
#include &quot;Carla/Sensor/SafeDistanceSensor.h&quot;

#include &quot;Carla/Actor/ActorBlueprintFunctionLibrary.h&quot;
#include &quot;Carla/Game/CarlaEpisode.h&quot;
#include &quot;Carla/Util/BoundingBoxCalculator.h&quot;
#include &quot;Carla/Vehicle/CarlaWheeledVehicle.h&quot;
</code></pre>
<p>然后我们就可以继续实现该功能了。构造函数将创建触发框，并告诉虚幻引擎4 我们希望调用我们的勾选函数。如果我们的传感器没有使用刻度功能，我们可以在此处禁用它以避免不必要的刻度</p>
<pre><code class="language-cpp">ASafeDistanceSensor::ASafeDistanceSensor(const FObjectInitializer &amp;ObjectInitializer)
  : Super(ObjectInitializer)
{
  Box = CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT(&quot;BoxOverlap&quot;));
  Box-&gt;SetupAttachment(RootComponent);
  Box-&gt;SetHiddenInGame(true); // Disable for debugging.
  Box-&gt;SetCollisionProfileName(FName(&quot;OverlapAll&quot;));

  PrimaryActorTick.bCanEverTick = true;
}
</code></pre>
<p>现在我们需要告诉 Carla 这个传感器有什么属性，这将用于在我们的蓝图库中创建一个新的蓝图，用户可以使用这个蓝图来配置和生成这个传感器。我们将在这里定义触发框的属性，在本例中我们将仅公开 X 和 Y 安全距离</p>
<pre><code class="language-cpp">FActorDefinition ASafeDistanceSensor::GetSensorDefinition()
{
  auto Definition = UActorBlueprintFunctionLibrary::MakeGenericSensorDefinition(
      TEXT(&quot;other&quot;),
      TEXT(&quot;safe_distance&quot;));

  FActorVariation Front;
  Front.Id = TEXT(&quot;safe_distance_front&quot;);
  Front.Type = EActorAttributeType::Float;
  Front.RecommendedValues = { TEXT(&quot;1.0&quot;) };
  Front.bRestrictToRecommended = false;

  FActorVariation Back;
  Back.Id = TEXT(&quot;safe_distance_back&quot;);
  Back.Type = EActorAttributeType::Float;
  Back.RecommendedValues = { TEXT(&quot;0.5&quot;) };
  Back.bRestrictToRecommended = false;

  FActorVariation Lateral;
  Lateral.Id = TEXT(&quot;safe_distance_lateral&quot;);
  Lateral.Type = EActorAttributeType::Float;
  Lateral.RecommendedValues = { TEXT(&quot;0.5&quot;) };
  Lateral.bRestrictToRecommended = false;

  Definition.Variations.Append({ Front, Back, Lateral });

  return Definition;
}
</code></pre>
<p>这样，传感器工厂就能够根据用户需求创建安全距离传感器。创建传感器后，立即使用用户请求的参数调用该<code>Set</code>函数</p>
<pre><code class="language-cpp">void ASafeDistanceSensor::Set(const FActorDescription &amp;Description)
{
  Super::Set(Description);

  float Front = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
      &quot;safe_distance_front&quot;,
      Description.Variations,
      1.0f);
  float Back = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
      &quot;safe_distance_back&quot;,
      Description.Variations,
      0.5f);
  float Lateral = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
      &quot;safe_distance_lateral&quot;,
      Description.Variations,
      0.5f);

  constexpr float M_TO_CM = 100.0f; // Unit conversion.

  float LocationX = M_TO_CM * (Front - Back) / 2.0f;
  float ExtentX = M_TO_CM * (Front + Back) / 2.0f;
  float ExtentY = M_TO_CM * Lateral;

  Box-&gt;SetRelativeLocation(FVector{LocationX, 0.0f, 0.0f});
  Box-&gt;SetBoxExtent(FVector{ExtentX, ExtentY, 0.0f});
}
</code></pre>
<p>请注意，set 函数是在虚幻引擎4 之前调用的<code>BeginPlay</code>，我们这里不会使用这个虚拟函数，但它对于其他传感器很重要。</p>
<p>现在我们将根据我们所附加的参与者的边界框来扩展盒子体积。为此，最方便的方法是使用 <code>SetOwner</code>虚函数。当我们的传感器连接到另一个参与者时，会调用此函数。</p>
<pre><code class="language-cpp">void ASafeDistanceSensor::SetOwner(AActor *Owner)
{
  Super::SetOwner(Owner);

  auto BoundingBox = UBoundingBoxCalculator::GetActorBoundingBox(Owner);

  Box-&gt;SetBoxExtent(BoundingBox.Extent + Box-&gt;GetUnscaledBoxExtent());
}
</code></pre>
<p>The only thing left to do is the actual measurement, for that we'll use the
<code>Tick</code> function. We're going to look for all the vehicles currently overlapping
our box, and we'll send this list to client</p>
<pre><code class="language-cpp">void ASafeDistanceSensor::Tick(float DeltaSeconds)
{
  Super::Tick(DeltaSeconds);

  TSet&lt;AActor *&gt; DetectedActors;
  Box-&gt;GetOverlappingActors(DetectedActors, ACarlaWheeledVehicle::StaticClass());
  DetectedActors.Remove(GetOwner());

  if (DetectedActors.Num() &gt; 0)
  {
    auto Stream = GetDataStream(*this);
    Stream.Send(*this, GetEpisode(), DetectedActors);
  }
}
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In production-ready sensors, the <code>Tick</code> function should be very optimized,
specially if the sensor sends big chunks of data. This function is called
every update in the game thread thus significantly affects the performance
of the simulator.</p>
</div>
<p>Ok, a couple of things going on here that we haven't mentioned yet, what's this
stream?</p>
<p>Every sensor has a data stream associated. This stream is used to send data down
to the client, and this is the stream you subscribe to when you use the
<code>sensor.listen(callback)</code> method in the Python API. Every time you send here
some data, the callback on the client-side is going to be triggered. But before
that, the data is going to travel through several layers. First of them will be
the serializer that we have to create next. We'll fully understand this part
once we have completed the <code>Serialize</code> function in the next section.</p>
<h3 id="2-">2- 传感器数据串行器</h3>
<p>This class is actually rather simple, it's only required to have two static
methods, <code>Serialize</code> and <code>Deserialize</code>. We'll add two files for it, this time to
LibCarla</p>
<ul>
<li><code>LibCarla/source/carla/sensor/s11n/SafeDistanceSerializer.h</code></li>
<li><code>LibCarla/source/carla/sensor/s11n/SafeDistanceSerializer.cpp</code></li>
</ul>
<p>Let's start with the <code>Serialize</code> function. This function is going to receive as
arguments whatever we pass to the <code>Stream.Send(...)</code> function, with the only
condition that the first argument has to be a sensor and it has to return a
buffer.</p>
<pre><code class="language-cpp">static Buffer Serialize(const Sensor &amp;, ...);
</code></pre>
<p>A <code>carla::Buffer</code> is just a dynamically allocated piece of raw memory with some
convenient functionality, we're going to use it to send raw data to the client.</p>
<p>In this example, we need to write the list of detected actors to a buffer in a
way that it can be meaningful in the client-side. That's why we passed the
episode object to this function.</p>
<p>The <code>UCarlaEpisode</code> class represent the current <em>episode</em> running in the
simulator, i.e. the state of the simulation since last time we loaded a map. It
contains all the relevant information to Carla, and among other things, it
allows searching for actor IDs. We can send these IDs to the client and the
client will be able to recognise these as actors</p>
<pre><code class="language-cpp">template &lt;typename SensorT, typename EpisodeT, typename ActorListT&gt;
static Buffer Serialize(
    const SensorT &amp;,
    const EpisodeT &amp;episode,
    const ActorListT &amp;detected_actors) {
  const uint32_t size_in_bytes = sizeof(ActorId) * detected_actors.Num();
  Buffer buffer{size_in_bytes};
  unsigned char *it = buffer.data();
  for (auto *actor : detected_actors) {
    ActorId id = episode.FindActor(actor).GetActorId();
    std::memcpy(it, &amp;id, sizeof(ActorId));
    it += sizeof(ActorId);
  }
  return buffer;
}
</code></pre>
<p>Note that we templatize the UE4 classes to avoid including these files within
LibCarla.</p>
<p>This buffer we're returning is going to come back to us, except that this time
in the client-side, in the <code>Deserialize</code> function packed in a <code>RawData</code> object</p>
<pre><code class="language-cpp">static SharedPtr&lt;SensorData&gt; Deserialize(RawData &amp;&amp;data);
</code></pre>
<p>We'll implement this method in the cpp file, and it's rather simple</p>
<pre><code class="language-cpp">SharedPtr&lt;SensorData&gt; SafeDistanceSerializer::Deserialize(RawData &amp;&amp;data) {
  return SharedPtr&lt;SensorData&gt;(new data::SafeDistanceEvent(std::move(data)));
}
</code></pre>
<p>except for the fact that we haven't defined yet what's a <code>SafeDistanceEvent</code>.</p>
<h3 id="3-">3- 传感器数据对象</h3>
<p>We need to create a data object for the users of this sensor, representing the
data of a <em>safe distance event</em>. We'll add this file to</p>
<ul>
<li><code>LibCarla/source/carla/sensor/data/SafeDistanceEvent.h</code></li>
</ul>
<p>This object is going to be equivalent to a list of actor IDs. For that, we'll
derive from the Array template</p>
<pre><code class="language-cpp">#pragma once

#include &quot;carla/rpc/ActorId.h&quot;
#include &quot;carla/sensor/data/Array.h&quot;

namespace carla {
namespace sensor {
namespace data {

  class SafeDistanceEvent : public Array&lt;rpc::ActorId&gt; {
  public:

    explicit SafeDistanceEvent(RawData &amp;&amp;data)
      : Array&lt;rpc::ActorId&gt;(std::move(data)) {}
  };

} // namespace data
} // namespace sensor
} // namespace carla
</code></pre>
<p>The Array template is going to reinterpret the buffer we created in the
<code>Serialize</code> method as an array of actor IDs, and it's able to do so directly
from the buffer we received, without allocating any new memory. Although for
this small example may seem a bit overkill, this mechanism is also used for big
chunks of data; imagine we're sending HD images, we save a lot by reusing the
raw memory.</p>
<p>Now we need to expose this class to Python. In our example, we haven't add any
extra methods, so we'll just expose the methods related to Array. We do so by
using Boost.Python bindings, add the following to
<em>PythonAPI/carla/source/libcarla/SensorData.cpp</em>.</p>
<pre><code class="language-cpp">class_&lt;
    csd::SafeDistanceEvent,                    // actual type.
    bases&lt;cs::SensorData&gt;,                     // parent type.
    boost::noncopyable,                        // disable copy.
    boost::shared_ptr&lt;csd::SafeDistanceEvent&gt;  // use as shared_ptr.
  &gt;(&quot;SafeDistanceEvent&quot;, no_init)              // name, and disable construction.
  .def(&quot;__len__&quot;, &amp;csd::SafeDistanceEvent::size)
  .def(&quot;__iter__&quot;, iterator&lt;csd::SafeDistanceEvent&gt;())
  .def(&quot;__getitem__&quot;, +[](const csd::SafeDistanceEvent &amp;self, size_t pos) -&gt; cr::ActorId {
    return self.at(pos);
  })
;
</code></pre>
<p>Note that <code>csd</code> is an alias for the namespace <code>carla::sensor::data</code>.</p>
<p>What we're doing here is exposing some C++ methods in Python. Just with this,
the Python API will be able to recognise our new event and it'll behave similar
to an array in Python, except that cannot be modified.</p>
<h3 id="4-">4- 注册您的传感器</h3>
<p>Now that the pipeline is complete, we're ready to register our new sensor. We do
so in <em>LibCarla/source/carla/sensor/SensorRegistry.h</em>. Follow the instruction in
this header file to add the different includes and forward declarations, and add
the following pair to the registry</p>
<pre><code class="language-cpp">std::pair&lt;ASafeDistanceSensor *, s11n::SafeDistanceSerializer&gt;
</code></pre>
<p>With this, the sensor registry now can do its magic to dispatch the right data
to the right serializer.</p>
<p>Now recompile Carla, hopefully everything goes ok and no errors. Unfortunately,
most of the errors here will be related to templates and the error messages can
be a bit cryptic.</p>
<pre><code>make rebuild
</code></pre>
<h3 id="5-">5- 使用示例</h3>
<p>Finally, we have the sensor included and we have finished recompiling, our
sensor by now should be available in Python.</p>
<p>To spawn this sensor, we simply need to find it in the blueprint library, if
everything went right, the sensor factory should have added our sensor to the
library</p>
<pre><code class="language-py">blueprint = blueprint_library.find('sensor.other.safe_distance')
sensor = world.spawn_actor(blueprint, carla.Transform(), attach_to=vehicle)
</code></pre>
<p>and now we can start listening for events by registering a callback function</p>
<pre><code class="language-py">world_ref = weakref.ref(world)

def callback(event):
    for actor_id in event:
        vehicle = world_ref().get_actor(actor_id)
        print('Vehicle too close: %s' % vehicle.type_id)

sensor.listen(callback)
</code></pre>
<p>This callback is going to execute every update that another vehicle is inside
our safety distance box, e.g.</p>
<pre><code>Vehicle too close: vehicle.audi.a2
Vehicle too close: vehicle.mercedes-benz.coupe
</code></pre>
<p>That's it, we have a new sensor working!</p>
<hr />
<h2 id="_5">附录</h2>
<h3 id="_6">重用缓冲区</h3>
<p>In order to optimize memory usage, we can use the fact that each sensor sends
buffers of similar size; in particularly, in the case of cameras, the size of
the image is constant during execution. In those cases, we can save a lot by
reusing the allocated memory between frames.</p>
<p>Each stream contains a <em>buffer pool</em> that can be used to avoid unnecessary
memory allocations. Remember that each sensor has a stream associated thus each
sensor has its own buffer pool.</p>
<p>Use the following to retrieve a buffer from the pool</p>
<pre><code class="language-cpp">auto Buffer = Stream.PopBufferFromPool();
</code></pre>
<p>If the pool is empty, it returns an empty buffer, i.e. a buffer with no memory
allocated. In that case, when you resize the buffer new memory will be
allocated. This will happen a few times during the first frames. However, if a
buffer was retrieved from the pool, its memory will go back to the pool once the
buffer goes out of the scope. Next time you get another buffer from the pool,
it'll contain the allocated piece of memory from the previous buffer. As you can
see, a buffer object acts actually as an smart pointer to a contiguous piece of
raw memory. As long as you don't request more memory than the currently
allocated, the buffer reuses the memory. If you request more, then it'll have to
delete the current memory and allocate a bigger chunk.</p>
<p>The following snippet illustrates how buffers work</p>
<pre><code class="language-cpp">Buffer buffer;
buffer.reset(1024u); // (size 1024 bytes, capacity 1024 bytes) -&gt; allocates
buffer.reset(512u);  // (size  512 bytes, capacity 1024 bytes)
buffer.reset(2048u); // (size 2048 bytes, capacity 2048 bytes) -&gt; allocates
</code></pre>
<h3 id="_7">异步发送数据</h3>
<p>Some sensors may require to send data asynchronously, either for performance or
because the data is generated in a different thread, for instance, camera sensors send
the images from the render thread.</p>
<p>Using the data stream asynchronously is perfectly fine, as long as the stream
itself is created in the game thread. For instance</p>
<pre><code class="language-cpp">void MySensor::Tick(float DeltaSeconds)
{
  Super::Tick(DeltaSeconds);

  auto Stream = GetDataStream(*this);

  std::async(std::launch::async, [Stream=std::move(Stream)]() {
    auto Data = ComputeData();
    Stream.Send(*this, Data);
  });
}
</code></pre>
<h3 id="_8">客户端传感器</h3>
<p>Some sensors do not require the simulator to do their measurements, those
sensors may run completely in the client-side freeing the simulator from extra
computations. Examples of such sensors is the <em>LaneInvasion</em> sensors.</p>
<p>The usual approach is to create a "dummy" sensor in the server-side, just so the
simulator is aware that such actor exists. However, this dummy sensor doesn't tick
nor sends any sort of data. Its counterpart on the client-side however,
registers a "on tick" callback to execute some code on every new update. For
instance, the LaneInvasion sensor registers a callback that notifies every time a
lane mark has been crossed.</p>
<p>It is very important to take into account that the "on tick" callback in the
client-side is executed concurrently, i.e., the same method may be executed
simultaneously by different threads. Any data accessed must be properly
synchronized, either with a mutex, using atomics, or even better making sure all
the members accessed remain constant.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../tuto_D_contribute_assets/" class="btn btn-neutral float-left" title="如何升级内容"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../tuto_D_create_semantic_tags/" class="btn btn-neutral float-right" title="创建语义标签">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../tuto_D_contribute_assets/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../tuto_D_create_semantic_tags/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../extra.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
