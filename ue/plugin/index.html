<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Carla 插件 - 代理模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Carla \u63d2\u4ef6";
        var mkdocs_page_input_path = "ue/plugin.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 代理模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">代理模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Carla 插件</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/ue/plugin.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="carla">Carla 插件</h1>
<p><img alt="" src="../../img/ue/plugin_directory.jpg" /></p>
<ul>
<li>Binaries：编译后的dll文件存放位置</li>
<li>Content：游戏资源Asset文件存放位置</li>
<li>Intermediate：编译的中间文件存放位置</li>
<li>Resources：一般为图标的存放位置</li>
<li>Source：代码存放位置</li>
<li>.uplugin：插件模块配置文件，JSON格式</li>
<li>.Build.cs：每个.Build.cs文件声明派生自<strong>ModuleRules</strong>基类的类，并设置属性控制器从构造函数进行编译的方式。由虚幻编译工具编译，并被构造来确定整体编译环境。使用C#语法。</li>
</ul>
<h2 id="carlauplugin">插件的描述文件 Carla.uplugin</h2>
<p><code>Carla.uplugin</code> 是插件json格式的插件描述文件，可以在插件编辑器中进行修改。</p>
<p><img alt="" src="../../img/ue/carla_uplugin.jpg" /></p>
<p>对应的文件内容为：</p>
<pre><code class="language-json">{
    &quot;FileVersion&quot;: 3,
    &quot;Version&quot;: 1,
    &quot;VersionName&quot;: &quot;0.9.15&quot;,
    &quot;FriendlyName&quot;: &quot;CARLA&quot;,
    &quot;Description&quot;: &quot;Open-source simulator for autonomous driving research.&quot;,
    &quot;Category&quot;: &quot;Science&quot;,
    &quot;CreatedBy&quot;: &quot;Computer Vision Center (CVC) at the Universitat Autonoma de Barcelona (UAB)&quot;,
    &quot;CreatedByURL&quot;: &quot;http://carla.org&quot;,
    &quot;DocsURL&quot;: &quot;http://carla.readthedocs.io&quot;,
    &quot;MarketplaceURL&quot;: &quot;&quot;,
    &quot;SupportURL&quot;: &quot;https://github.com/carla-simulator/carla/issues&quot;,
    &quot;CanContainContent&quot;: true,
    &quot;IsBetaVersion&quot;: true,
    &quot;Installed&quot;: true,
    &quot;Modules&quot;: [
        {
            &quot;Name&quot;: &quot;Carla&quot;,
            &quot;Type&quot;: &quot;Runtime&quot;,
            &quot;LoadingPhase&quot;: &quot;PreDefault&quot;,
            &quot;AdditionalDependencies&quot;: [
                &quot;Engine&quot;
            ]
        }
    ],
    &quot;Plugins&quot;: [
        {
            &quot;Name&quot;: &quot;PhysXVehicles&quot;,
            &quot;Enabled&quot;: true
        },
        {
            &quot;Name&quot;: &quot;ProceduralMeshComponent&quot;,
            &quot;Enabled&quot;: true
        }
    ]
}
</code></pre>
<p><strong>模块描述符Modules</strong> 必须有Name和Type字段。</p>
<ul>
<li>Name：是插件模块的唯一命名，将随着插件而加载。在运行时，插件的Binaries文件夹中需存在正确的插件二进制文件，并带有指定模块命名。</li>
<li>Type：是模块的类型，决定了该插件<strong>适合于那种类型的应用程序加载</strong>。有效的几项是：Runtime、RuntimeNoCommandlet、Developer、Editor；其中 <strong>Runtime</strong> 的模块在无论何时都会被加载，哪怕是在最终发行的游戏版本中也会。Developer 的模块只会在 <strong>Development</strong> 运行时或者编辑器版本中才会被加载，并不在在最终发行版本中加载。<strong>Editor</strong> 模块只会随着 Editor 的启动被加载。插件也可以使用几种不同类型的组合来达到所需要的目的。</li>
<li>LoadingPhase：控制插件在引擎启动的何时被加载。</li>
</ul>
<h2 id="carlabuildcs">插件的编译配置文件 Carla.Build.cs 描述模块编译方法</h2>
<details>
<summary><b>Carla.Build.cs</b> </summary>


<pre><code class="language-json">// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

using System;
using System.IO;
using UnrealBuildTool;

public class Carla : ModuleRules
{
  bool UsingCarSim = false;
  bool UsingChrono = false;
  bool UsingPytorch = false;
  bool UsingRos2 = false;
  private bool IsWindows(ReadOnlyTargetRules Target)
  {
    return (Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32);
  }

  public Carla(ReadOnlyTargetRules Target) : base(Target)
  {
    PrivatePCHHeaderFile = &quot;Carla.h&quot;;

    if (IsWindows(Target))
    {
      bEnableExceptions = true;
    }

    // Read config about carsim
    string CarlaPluginPath = Path.GetFullPath( ModuleDirectory );
    string ConfigDir =  Path.GetFullPath(Path.Combine(CarlaPluginPath, &quot;../../../../Config/&quot;));
    string OptionalModulesFile = Path.Combine(ConfigDir, &quot;OptionalModules.ini&quot;);
    string[] text = System.IO.File.ReadAllLines(OptionalModulesFile);
    foreach (string line in text)
    {
      if (line.Contains(&quot;CarSim ON&quot;))
      {
        Console.WriteLine(&quot;Enabling carsim&quot;);
        UsingCarSim = true;
        PublicDefinitions.Add(&quot;WITH_CARSIM&quot;);
        PrivateDefinitions.Add(&quot;WITH_CARSIM&quot;);
      }
      if (line.Contains(&quot;Chrono ON&quot;))
      {
        Console.WriteLine(&quot;Enabling chrono&quot;);
        UsingChrono = true;
        PublicDefinitions.Add(&quot;WITH_CHRONO&quot;);
        PrivateDefinitions.Add(&quot;WITH_CHRONO&quot;);
      }
      if (line.Contains(&quot;Pytorch ON&quot;))
      {
        Console.WriteLine(&quot;Enabling pytorch&quot;);
        UsingPytorch = true;
        PublicDefinitions.Add(&quot;WITH_PYTORCH&quot;);
        PrivateDefinitions.Add(&quot;WITH_PYTORCH&quot;);
      }

      if (line.Contains(&quot;Ros2 ON&quot;))
      {
        Console.WriteLine(&quot;Enabling ros2&quot;);
        UsingRos2 = true;
        PublicDefinitions.Add(&quot;WITH_ROS2&quot;);
        PrivateDefinitions.Add(&quot;WITH_ROS2&quot;);
      }
    }

    PublicIncludePaths.AddRange(
      new string[] {
        // ... add public include paths required here ...
      }
      );

    PrivateIncludePaths.AddRange(
      new string[] {
        // ... add other private include paths required here ...
      }
      );

    PublicDependencyModuleNames.AddRange(
      new string[]
      {
        &quot;Core&quot;,
        &quot;RenderCore&quot;,
        &quot;RHI&quot;,
        &quot;Renderer&quot;,
        &quot;ProceduralMeshComponent&quot;,
        &quot;MeshDescription&quot;
        // ... add other public dependencies that you statically link with here ...
      }
      );
    if (UsingCarSim)
    {
      PublicDependencyModuleNames.AddRange(new string[] { &quot;CarSim&quot; });
    }

     if (Target.Type == TargetType.Editor)
     {
        PublicDependencyModuleNames.AddRange(new string[] { &quot;UnrealEd&quot; });
     }

    PrivateDependencyModuleNames.AddRange(
      new string[]
      {
        &quot;AIModule&quot;,
        &quot;AssetRegistry&quot;,
        &quot;CoreUObject&quot;,
        &quot;Engine&quot;,
        &quot;Foliage&quot;,
        &quot;HTTP&quot;,
        &quot;StaticMeshDescription&quot;,
        &quot;ImageWriteQueue&quot;,
        &quot;Json&quot;,
        &quot;JsonUtilities&quot;,
        &quot;Landscape&quot;,
        &quot;PhysX&quot;,
        &quot;PhysXVehicles&quot;,
        &quot;PhysXVehicleLib&quot;,
        &quot;Slate&quot;,
        &quot;SlateCore&quot;,
        &quot;PhysicsCore&quot;
        // ... add private dependencies that you statically link with here ...
      }
      );
    if (UsingCarSim)
    {
      PrivateDependencyModuleNames.AddRange(new string[] { &quot;CarSim&quot; });
      PrivateIncludePathModuleNames.AddRange(new string[] { &quot;CarSim&quot; });
    }


    DynamicallyLoadedModuleNames.AddRange(
      new string[]
      {
        // ... add any modules that your module loads dynamically here ...
      }
      );

    AddCarlaServerDependency(Target);
  }

  private bool UseDebugLibs(ReadOnlyTargetRules Target)
  {
    if (IsWindows(Target))
    {
      // In Windows, Unreal uses the Release C++ Runtime (CRT) even in debug
      // mode, so unless we recompile the engine we cannot link the debug
      // libraries.
      return false;
    }
    else
    {
      return false;
    }
  }

  private void AddDynamicLibrary(string library)
  {
    PublicAdditionalLibraries.Add(library);
    RuntimeDependencies.Add(library);
    PublicDelayLoadDLLs.Add(library);
  }
  private void AddDllDependency(string PathToFolder, string DllName)
  {
    string Source = Path.Combine(PathToFolder, DllName);
    string Destination = Path.Combine(&quot;$(BinaryOutputDir)&quot;, DllName);
    RuntimeDependencies.Add(Destination, Source);
  }

  delegate string ADelegate(string s);

  private void AddBoostLibs(string LibPath)
  {
    string [] files = Directory.GetFiles(LibPath, &quot;*boost*.lib&quot;);
    foreach (string file in files) PublicAdditionalLibraries.Add(file);
  }

  private void AddCarlaServerDependency(ReadOnlyTargetRules Target)
  {
    string LibCarlaInstallPath = Path.GetFullPath(Path.Combine(ModuleDirectory, &quot;../../CarlaDependencies&quot;));

    ADelegate GetLibName = (string BaseName) =&gt; {
      if (IsWindows(Target))
      {
        return BaseName + &quot;.lib&quot;;
      }
      else
      {
        return &quot;lib&quot; + BaseName + &quot;.a&quot;;
      }
    };

    // Link dependencies.
    if (IsWindows(Target))
    {
      AddBoostLibs(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;rpc&quot;)));

      if (UseDebugLibs(Target))
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_server_debug&quot;)));
      }
      else
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_server&quot;)));
      }
      if (UsingChrono)
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;ChronoEngine&quot;)));
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;ChronoEngine_vehicle&quot;)));
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;ChronoModels_vehicle&quot;)));
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;ChronoModels_robot&quot;)));
        AddDllDependency(Path.Combine(LibCarlaInstallPath, &quot;dll&quot;), &quot;ChronoEngine.dll&quot;);
        AddDllDependency(Path.Combine(LibCarlaInstallPath, &quot;dll&quot;), &quot;ChronoEngine_vehicle.dll&quot;);
        AddDllDependency(Path.Combine(LibCarlaInstallPath, &quot;dll&quot;), &quot;ChronoModels_vehicle.dll&quot;);
        AddDllDependency(Path.Combine(LibCarlaInstallPath, &quot;dll&quot;), &quot;ChronoModels_robot.dll&quot;);
        bUseRTTI = true;
      }

      //OsmToODR
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;sqlite3.lib&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;xerces-c_3.lib&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;proj.lib&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;osm2odr.lib&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;zlibstatic.lib&quot;));
    }
    else
    {
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;rpc&quot;)));
      if (UseDebugLibs(Target))
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_server_debug&quot;)));
      }
      else
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_server&quot;)));
      }
      if (UsingChrono)
      {
        AddDynamicLibrary(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libChronoEngine.so&quot;));
        AddDynamicLibrary(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libChronoEngine_vehicle.so&quot;));
        AddDynamicLibrary(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libChronoModels_vehicle.so&quot;));
        AddDynamicLibrary(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libChronoModels_robot.so&quot;));

        bUseRTTI = true;
      }

      if (UsingPytorch)
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_pytorch&quot;)));

        string LibTorchPath = LibCarlaInstallPath;
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libonnx_proto.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libfbgemm.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgloo.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libXNNPACK.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libprotobuf-lite.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libprotobuf.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libasmjit.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libcpuinfo_internals.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libclog.a&quot;));
        // PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libbreakpad_common.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libbenchmark.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtensorpipe.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libpytorch_qnnpack.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtensorpipe_cuda.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnnpack_reference_layers.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgmock.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libdnnl.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libpthreadpool.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libcpuinfo.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libqnnpack.a&quot;));
        // PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libbreakpad.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libkineto.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libprotoc.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgtest.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgmock_main.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgtest_main.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libbenchmark_main.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libfmt.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtensorpipe_uv.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libfoxi_loader.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgloo_cuda.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnnpack.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libcaffe2_protos.a&quot;));
        PublicAdditionalLibraries.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libonnx.a&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnnapi_backend.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libbackend_with_compiler.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libcaffe2_nvrtc.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch_cuda_cpp.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libc10_cuda.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorchbind_test.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libjitbackend_test.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libc10.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch_cuda.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch_global_deps.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch_cpu.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libshm.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorch_cuda_cu.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorchscatter.so&quot;));
        AddDynamicLibrary(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libtorchcluster.so&quot;));
        // AddDynamicLibrary(&quot;/usr/local/cuda/lib64/stubs/libcuda.so&quot;);
        // AddDynamicLibrary(&quot;/usr/local/cuda/lib64/libnvrtc.so&quot;);
        // AddDynamicLibrary(&quot;/usr/local/cuda/lib64/libnvToolsExt.so&quot;);
        // AddDynamicLibrary(&quot;/usr/local/cuda/lib64/libcudart.so&quot;);
        // AddDynamicLibrary(&quot;/usr/lib/llvm-10/lib/libgomp.so&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/local/cuda/lib64/stubs/libcuda.so&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/local/cuda/lib64/libnvrtc.so&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/local/cuda/lib64/libnvToolsExt.so&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/local/cuda/lib64/libcudart.so&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/lib/llvm-10/lib/libgomp.so&quot;);
        RuntimeDependencies.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libcudart-a7b20f20.so.11.0&quot;));
        RuntimeDependencies.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libgomp-a34b3233.so.1&quot;));
        RuntimeDependencies.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnvrtc-builtins-4730a239.so.11.3&quot;));
        RuntimeDependencies.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnvrtc-1ea278b5.so.11.2&quot;));
        RuntimeDependencies.Add(Path.Combine(LibTorchPath, &quot;lib&quot;, &quot;libnvToolsExt-24de1d56.so.1&quot;));
        PublicAdditionalLibraries.Add(&quot;stdc++&quot;);
        PublicAdditionalLibraries.Add(&quot;/usr/lib/x86_64-linux-gnu/libpython3.9.so&quot;);
      }

      if (UsingRos2)
      {
        PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, GetLibName(&quot;carla_fastdds&quot;)));

        string LibFastDDSPath = LibCarlaInstallPath;
        AddDynamicLibrary(Path.Combine(LibFastDDSPath, &quot;lib&quot;, &quot;libfoonathan_memory-0.7.3.so&quot;));
        AddDynamicLibrary(Path.Combine(LibFastDDSPath, &quot;lib&quot;, &quot;libfastcdr.so&quot;));
        AddDynamicLibrary(Path.Combine(LibFastDDSPath, &quot;lib&quot;, &quot;libfastrtps.so&quot;));
        PublicAdditionalLibraries.Add(&quot;stdc++&quot;);
      }


      //OsmToODR
      PublicAdditionalLibraries.Add(&quot;/usr/lib/x86_64-linux-gnu/libc.so&quot;);
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libsqlite3.so&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libxerces-c.a&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libproj.a&quot;));
      PublicAdditionalLibraries.Add(Path.Combine(LibCarlaInstallPath, &quot;lib&quot;, &quot;libosm2odr.a&quot;));

    }
    bEnableExceptions = true;

    // Include path.
    string LibCarlaIncludePath = Path.Combine(LibCarlaInstallPath, &quot;include&quot;);

    PublicIncludePaths.Add(LibCarlaIncludePath);
    PrivateIncludePaths.Add(LibCarlaIncludePath);

    PublicDefinitions.Add(&quot;ASIO_NO_EXCEPTIONS&quot;);
    PublicDefinitions.Add(&quot;BOOST_NO_EXCEPTIONS&quot;);
    PublicDefinitions.Add(&quot;LIBCARLA_NO_EXCEPTIONS&quot;);
    PublicDefinitions.Add(&quot;PUGIXML_NO_EXCEPTIONS&quot;);
    PublicDefinitions.Add(&quot;BOOST_DISABLE_ABI_HEADERS&quot;);
    PublicDefinitions.Add(&quot;BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY&quot;);
  }
}
</code></pre>


</details>

<h3 id="buildcsvs">Build.cs与VS的关系</h3>
<p>该插件模块编译配置，与配置VS中的项目属性类似，包含进了依赖库等。包括虚幻引擎、VS、Windows Kits的头文件目录：
<img alt="" src="../../img/ue/Carla.Build.cs.jpg" /></p>
<p>读取配置文件<code>Unreal/CarlaUE4/Config/OptionalModules.ini</code>，决定是否加载某一模块，包括 Carsim、Chrono、Pytorch、Ros2。</p>
<h3 id="carlah">插件头文件 Carla.h</h3>
<p>插件的头文件中，一般只有一个类，而且以F开头，Module结尾。比如：<a href="https://github.com/OpenHUTB/carla/blob/ue4-dev/Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Carla.h">FCarlaModule</a> 。
还有两个函数</p>
<pre><code class="language-json">virtual void StartupModule() override;//插件加载
virtual void ShutdownModule() override;//插件卸载
</code></pre>
<h2 id="_1">使用引擎插件</h2>
<p>直接包含插件头文件是不行的。打开插件的 Carla.Build.cs 文件，在 PublicDependencyModuleNames 中，填入使用的插件名称：</p>
<pre><code class="language-json">PublicDependencyModuleNames.AddRange(
      new string[]
      {
        &quot;Core&quot;,
        &quot;RenderCore&quot;,
        &quot;RHI&quot;,
        &quot;Renderer&quot;,
        &quot;ProceduralMeshComponent&quot;,
        &quot;MeshDescription&quot;
        // ... add other public dependencies that you statically link with here ...
      }
      );
</code></pre>
<h2 id="_2">参考</h2>
<ul>
<li><a href="https://www.jianshu.com/p/e41a810b10ca">Unreal 插件</a></li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../extra.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
